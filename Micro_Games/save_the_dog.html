<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Save the Doge: Ultimate</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: 'Arial', sans-serif; touch-action: none; user-select: none; }
        
        /* UI OVERLAY */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; align-items: center; justify-content: space-between;
        }

        /* HUD */
        #top-bar { margin-top: 20px; width: 90%; text-align: center; }
        #level-indicator { font-size: 24px; font-weight: bold; color: white; text-shadow: 2px 2px 0 #000; }
        #timer-bar {
            width: 100%; height: 15px; background: rgba(0,0,0,0.3); border-radius: 10px; margin-top: 10px; overflow: hidden;
            display: none; /* Hidden until simulation starts */
        }
        #timer-fill { height: 100%; background: #f1c40f; width: 100%; transition: width 0.1s linear; }

        /* POPUPS */
        #status-msg {
            font-size: 50px; font-weight: 900; color: white; text-shadow: 3px 3px 0 #000;
            position: absolute; top: 40%; display: none;
        }

        /* BUTTONS */
        #controls { pointer-events: auto; margin-bottom: 50px; display: none; }
        .btn {
            padding: 15px 40px; font-size: 20px; border: none; border-radius: 50px;
            color: white; font-weight: bold; cursor: pointer; box-shadow: 0 6px rgba(0,0,0,0.3);
            text-transform: uppercase; letter-spacing: 1px; transition: transform 0.1s;
        }
        .btn:active { transform: translateY(4px); box-shadow: 0 2px rgba(0,0,0,0.3); }
        .btn-next { background: #2ecc71; }
        .btn-retry { background: #e74c3c; }

        /* CANVAS */
        canvas { display: block; width: 100%; height: 100%; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="top-bar">
            <div id="level-indicator">Level 1</div>
            <div id="hint" style="font-size: 14px; color: #fff; margin-top:5px;">Draw to protect the Doge!</div>
            <div id="timer-bar"><div id="timer-fill"></div></div>
        </div>

        <div id="status-msg">SAFE!</div>

        <div id="controls">
            <button class="btn btn-next" onclick="nextLevel()">Next Level</button>
            <button class="btn btn-retry" onclick="resetLevel()">Retry</button>
        </div>
    </div>

<script>
    // --- MATTER.JS SETUP ---
    const Engine = Matter.Engine,
          Render = Matter.Render,
          Runner = Matter.Runner,
          Composite = Matter.Composite,
          Bodies = Matter.Bodies,
          Body = Matter.Body,
          Events = Matter.Events,
          Vector = Matter.Vector,
          Vertices = Matter.Vertices;

    const engine = Engine.create();
    const world = engine.world;
    
    // Disable gravity initially (until user draws)
    engine.gravity.y = 1; 

    const render = Render.create({
        element: document.body,
        engine: engine,
        options: {
            width: window.innerWidth,
            height: window.innerHeight,
            wireframes: false,
            background: 'transparent',
            pixelRatio: window.devicePixelRatio // Sharp rendering
        }
    });

    Render.run(render);
    const runner = Runner.create();
    Runner.run(runner, engine);

    // --- GAME VARIABLES ---
    let doge;
    let bees = [];
    let walls = [];
    let isDrawing = false;
    let points = [];
    let simStarted = false;
    let gameOver = false;
    let currentLevel = 1;
    let timeLeft = 10;
    let beeInterval;
    let timerInterval;

    // --- LEVELS CONFIG ---
    // Coordinates are 0.0 to 1.0 (Percentage of screen width/height)
    const levels = [
        // Level 1: Flat Ground
        {
            dog: { x: 0.5, y: 0.85 },
            hive: { x: 0.5, y: 0.2 },
            walls: [
                { x: 0.5, y: 1.0, w: 1.0, h: 0.1 } // Floor
            ]
        },
        // Level 2: The Cliff (Requires drawing a wall on the side)
        {
            dog: { x: 0.2, y: 0.6 },
            hive: { x: 0.8, y: 0.2 },
            walls: [
                { x: 0.2, y: 0.7, w: 0.4, h: 0.05 }, // Platform
                { x: 0.5, y: 1.0, w: 1.0, h: 0.1 }   // Floor (Safety net below)
            ]
        },
        // Level 3: Floating Island (Requires hooking)
        {
            dog: { x: 0.5, y: 0.5 },
            hive: { x: 0.5, y: 0.15 },
            walls: [
                { x: 0.5, y: 0.6, w: 0.3, h: 0.05 }  // Island
            ]
        }
    ];

    function loadLevel(lvlIdx) {
        // Cleanup
        Composite.clear(world);
        engine.events = {}; 
        bees = [];
        walls = [];
        points = [];
        isDrawing = false;
        simStarted = false;
        gameOver = false;
        timeLeft = 10;
        clearInterval(beeInterval);
        clearInterval(timerInterval);

        // UI Reset
        document.getElementById('status-msg').style.display = 'none';
        document.getElementById('controls').style.display = 'none';
        document.getElementById('timer-bar').style.display = 'none';
        document.getElementById('timer-fill').style.width = '100%';
        document.getElementById('level-indicator').innerText = `Level ${lvlIdx}`;
        document.querySelector('.btn-next').style.display = 'none';
        document.querySelector('.btn-retry').style.display = 'none';

        // Load Physics Objects
        const data = levels[lvlIdx - 1];
        const w = window.innerWidth;
        const h = window.innerHeight;

        // 1. Create Walls/Ground
        data.walls.forEach(wall => {
            const rect = Bodies.rectangle(
                wall.x * w, wall.y * h, 
                wall.w * w, wall.h * h, 
                { 
                    isStatic: true,
                    render: { fillStyle: '#2ecc71', strokeStyle: '#27ae60', lineWidth: 2 }
                }
            );
            walls.push(rect);
        });

        // 2. Create invisible bounds so items don't fly off sides
        walls.push(Bodies.rectangle(-25, h/2, 50, h, { isStatic: true, render: { visible: false } })); // Left
        walls.push(Bodies.rectangle(w+25, h/2, 50, h, { isStatic: true, render: { visible: false } })); // Right

        // 3. Create Doge
        doge = Bodies.circle(data.dog.x * w, data.dog.y * h, 20, {
            restitution: 0.0, // Don't bounce too much
            friction: 1.0,    // Don't slide easily
            density: 0.005,   // Heavy enough
            render: { fillStyle: 'transparent' } // We will draw emoji
        });

        // 4. Hive Position
        hivePos = { x: data.hive.x * w, y: data.hive.y * h };

        Composite.add(world, [...walls, doge]);
        
        // Re-attach Game Loop
        Events.on(engine, 'beforeUpdate', gameLoop);
    }

    // --- DRAWING LOGIC ---
    // We draw a line, then convert it to a static body initially? 
    // No, standard gameplay is: Draw Line -> Release -> Physics Starts -> Line Falls

    const canvas = document.querySelector('canvas');
    
    // Input Listeners
    canvas.addEventListener('mousedown', startDraw);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', endDraw);
    canvas.addEventListener('touchstart', (e) => { e.preventDefault(); startDraw(e.touches[0]); }, {passive:false});
    canvas.addEventListener('touchmove', (e) => { e.preventDefault(); draw(e.touches[0]); }, {passive:false});
    canvas.addEventListener('touchend', endDraw);

    function startDraw(e) {
        if (simStarted || gameOver) return;
        isDrawing = true;
        points = [{ x: e.clientX, y: e.clientY }];
    }

    function draw(e) {
        if (!isDrawing) return;
        const last = points[points.length - 1];
        const dist = Math.hypot(e.clientX - last.x, e.clientY - last.y);

        // Smooth drawing: only add point if moved 10px
        if (dist > 10) {
            points.push({ x: e.clientX, y: e.clientY });
            drawPreview(); // Visual only
        }
    }

    function endDraw() {
        if (!isDrawing) return;
        isDrawing = false;
        if (points.length < 3) return; // Too short

        createPhysicsBodyFromLine();
        startSimulation();
    }

    // Visual Preview of Line (Canvas 2D)
    function drawPreview() {
        const ctx = render.context;
        ctx.beginPath();
        ctx.lineWidth = 10;
        ctx.lineCap = 'round';
        ctx.strokeStyle = '#333';
        
        ctx.moveTo(points[0].x, points[0].y);
        for(let i=1; i<points.length; i++){
            ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.stroke();
    }

    function createPhysicsBodyFromLine() {
        // Create a chain of rectangles to simulate a thick line
        const parts = [];
        const thickness = 10;
        
        for (let i = 0; i < points.length - 1; i++) {
            const p1 = points[i];
            const p2 = points[i+1];
            
            const cx = (p1.x + p2.x) / 2;
            const cy = (p1.y + p2.y) / 2;
            const len = Math.hypot(p2.x - p1.x, p2.y - p1.y);
            const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);

            parts.push(Bodies.rectangle(cx, cy, len, thickness, {
                angle: angle,
                render: { fillStyle: '#333' }
            }));
        }

        // Combine parts into one rigid body
        const shield = Body.create({
            parts: parts,
            friction: 0.8,  // High friction to grip ground
            restitution: 0.1, // Low bounce
            density: 0.002    // Heavy enough to block bees
        });

        Composite.add(world, shield);
    }

    // --- GAMEPLAY LOGIC ---

    function startSimulation() {
        if (simStarted) return;
        simStarted = true;
        
        document.getElementById('timer-bar').style.display = 'block';

        // 1. Timer
        timerInterval = setInterval(() => {
            if (gameOver) return;
            timeLeft -= 0.1;
            document.getElementById('timer-fill').style.width = (timeLeft * 10) + '%';
            if (timeLeft <= 0) winGame();
        }, 100);

        // 2. Spawn Bees
        let beesSpawned = 0;
        beeInterval = setInterval(() => {
            if (gameOver || beesSpawned > 20) return;
            spawnBee();
            beesSpawned++;
        }, 400); // Fast spawn
    }

    function spawnBee() {
        const bee = Bodies.circle(hivePos.x, hivePos.y, 8, {
            frictionAir: 0,
            restitution: 1.1, // Very bouncy
            render: { fillStyle: 'transparent' }
        });
        
        // Initial push random
        Body.setVelocity(bee, { 
            x: (Math.random() - 0.5) * 10, 
            y: (Math.random() - 0.5) * 10 
        });

        bees.push(bee);
        Composite.add(world, bee);
    }

    function gameLoop() {
        if (gameOver) return;

        // BEE AI: Hunt Doge
        bees.forEach(bee => {
            const dx = doge.position.x - bee.position.x;
            const dy = doge.position.y - bee.position.y;
            const dist = Math.hypot(dx, dy);

            // Apply force towards dog
            const strength = 0.00008; 
            Body.applyForce(bee, bee.position, {
                x: (dx / dist) * strength,
                y: (dy / dist) * strength
            });

            // Collision check
            if (dist < 28) loseGame(); // Bee touched Dog
        });

        // Dog fell off screen
        if (doge.position.y > window.innerHeight) loseGame();
    }

    // --- RENDERING OVERLAYS (EMOJIS) ---
    Events.on(render, 'afterRender', () => {
        const ctx = render.context;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        // Draw Doge
        ctx.save();
        ctx.translate(doge.position.x, doge.position.y);
        ctx.rotate(doge.angle);
        ctx.font = "30px Arial";
        ctx.fillText(gameOver && !points.length ? "" : (gameOver && timeLeft > 0 ? "ðŸ˜­" : "ðŸ¶"), 0, 0);
        ctx.restore();

        // Draw Bees
        ctx.font = "16px Arial";
        bees.forEach(bee => {
            ctx.fillText("ðŸ", bee.position.x, bee.position.y);
        });

        // Draw Hive
        ctx.font = "40px Arial";
        ctx.fillText("ðŸª¹", hivePos.x, hivePos.y);

        // Draw Preview Line while drawing
        if(isDrawing && points.length > 1) drawPreview();
    });

    // --- WIN/LOSS STATES ---

    function winGame() {
        if(gameOver) return;
        gameOver = true;
        clearInterval(beeInterval);
        clearInterval(timerInterval);
        
        const msg = document.getElementById('status-msg');
        msg.innerText = "SAFE!";
        msg.style.color = "#2ecc71";
        msg.style.display = 'block';

        document.getElementById('controls').style.display = 'block';
        document.querySelector('.btn-next').style.display = 'inline-block';
        document.querySelector('.btn-retry').style.display = 'none';
    }

    function loseGame() {
        if(gameOver) return;
        gameOver = true;
        clearInterval(beeInterval);
        clearInterval(timerInterval);

        const msg = document.getElementById('status-msg');
        msg.innerText = "STUNG!";
        msg.style.color = "#e74c3c";
        msg.style.display = 'block';

        document.getElementById('controls').style.display = 'block';
        document.querySelector('.btn-next').style.display = 'none';
        document.querySelector('.btn-retry').style.display = 'inline-block';
    }

    // --- NAVIGATION ---
    function resetLevel() {
        loadLevel(currentLevel);
    }

    function nextLevel() {
        currentLevel++;
        if(currentLevel > levels.length) currentLevel = 1;
        loadLevel(currentLevel);
    }

    // Start
    window.onload = () => loadLevel(1);
    
    // Resize Handle
    window.onresize = () => {
        render.canvas.width = window.innerWidth;
        render.canvas.height = window.innerHeight;
    };

</script>
</body>
</html>
